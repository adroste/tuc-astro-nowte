<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/api/controller/user.js | nowte-server</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#api-controller">api/controller</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-checkTitleIsNoDuplicate">checkTitleIsNoDuplicate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create">create</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFilePermissions">getFilePermissions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFolderListing">getFolderListing</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-changePasswordViaCurrentPassword">changePasswordViaCurrentPassword</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-changePasswordViaResetToken">changePasswordViaResetToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-comparePassword">comparePassword</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createAndSendEmailValidationToken">createAndSendEmailValidationToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createAndSendPasswordResetToken">createAndSendPasswordResetToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEmailValidationToken">createEmailValidationToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createPasswordResetToken">createPasswordResetToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSessionToken">createSessionToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createUser">createUser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extractJwt">extractJwt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hashPassword">hashPassword</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-login">login</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-logout">logout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-revokeAllSessions">revokeAllSessions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateSession">validateSession</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateSessionAsyncWrapper">validateSessionAsyncWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateUserEmail">validateUserEmail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-conditionalThrowWithStatus">conditionalThrowWithStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createPermissionsObject">createPermissionsObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fixPermissionsObject">fixPermissionsObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-requireVarWithType">requireVarWithType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-throwAndLog">throwAndLog</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#api-models">api/models</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Document">Document</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Folder">Folder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Share">Share</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-User">User</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#api-routes">api/routes</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-asyncMiddleware">asyncMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-router">router</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-router">router</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#init">init</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get">get</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FROM">FROM</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-transporter">transporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-db">db</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/api/controller/user.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @author progmem
 * @date 22.10.17
 */

&apos;use strict&apos;;

// -------------------------------------------
// Includes
// -------------------------------------------
const config = require(&apos;../../init/config&apos;);
const jwt = require(&apos;jsonwebtoken&apos;);
const bcrypt = require(&apos;bcrypt&apos;);
const mailer = require(&apos;../../init/mailer-init&apos;);
const User = require(&apos;../models/user&apos;).User;
const Folder = require(&apos;../models/folder&apos;).Folder;
const mongoose = require(&apos;mongoose&apos;);


// -------------------------------------------
// Globals
// -------------------------------------------
const FRONTEND_URL = config.get(&apos;web-frontend.url&apos;);
const SALTING_ROUNDS = config.get(&apos;user.password-salting-rounds&apos;);
// TODO advanced: private key rotation
const PRIVATE_KEY = config.get(&apos;user.private-key&apos;);
const MAIL_ACTIVATE_USER_SUBJECT = config.get(&apos;templates.mail.activateUserAccount.subject&apos;);
const MAIL_ACTIVATE_USER_BODY = config.get(&apos;templates.mail.activateUserAccount.body&apos;);
// TODO validate email request url should lead to a react screen witch handles api call instead of naked api call
const REQUEST_URL_VALIDATE_EMAIL = FRONTEND_URL + &apos;/email-validation-done/:token&apos;;
const MAIL_RESET_PASSWORD_SUBJECT = config.get(&apos;templates.mail.resetPassword.subject&apos;);
const MAIL_RESET_PASSWORD_BODY = config.get(&apos;templates.mail.resetPassword.body&apos;);
const REQUEST_URL_RESET_PASSWORD = FRONTEND_URL + &apos;/reset-password/:token&apos;;


// -------------------------------------------
// JWT
// -------------------------------------------
/**
 * Creates a JWT containing userId that expires in 24h (for email validation).
 * @param userId
 * @param cb func(err, token)
 */
function createEmailValidationToken(userId, cb) {
    createJwt({
        userId: userId
    }, &apos;24h&apos;, cb);
}
exports.createEmailValidationToken = createEmailValidationToken;


/**
 * Creates a JWT containing payload.
 * @param payload
 * @param expiresIn expressed in seconds or a string describing a time span. Eg: 60, &quot;2 days&quot;, &quot;10h&quot;, &quot;7d&quot; (null = unlimited)
 * @param cb func(err, token)
 */
function createJwt(payload, expiresIn, cb) {
    const options = { algorithm: &apos;HS256&apos; };
    if (expiresIn)
        Object.assign(options, { expiresIn: expiresIn });
    jwt.sign(payload, PRIVATE_KEY, options, (err, token) =&gt; {
        if (err) {
            const err2 = new Error(&apos;could not create token: &apos; + err.message);
            err2.status = 500; // Internal Server Error
            return cb(err);
        }
        return cb(null, token);
    });
}


/**
 * Creates a JWT containing userId that expires in 1h (for password reset).
 * @param userId
 * @param cb func(err, token)
 */
function createPasswordResetToken(userId, cb) {
    createJwt({
        userId: userId
    }, &apos;1h&apos;, cb);
}
exports.createPasswordResetToken = createPasswordResetToken;


/**
 * Creates a JWT containing userId and sessionId.
 * Session tokens do not expire, expiry is set in db
 * @param userId
 * @param sessionId
 * @param cb func(err, token)
 */
function createSessionToken(userId, sessionId, cb) {
    createJwt({
        userId: userId,
        sessionId: sessionId
    }, null, cb);
}
exports.createSessionToken = createSessionToken;


/**
 * Verifies und returns the payload of a jwt. Content could be bullsh*t if private key got leaked.
 * @param token
 * @param cb func(err, decodedToken)
 */
function extractJwt(token, cb) {
    if (typeof token !== &apos;string&apos;) {
        const err = new Error(&apos;token invalid type, token is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }

    jwt.verify(token, PRIVATE_KEY, { algorithms: [&apos;HS256&apos;] }, (err, decodedToken) =&gt; {
        if (err) {
            const err2 = new Error(&apos;invalid token: &apos; + err.message);
            err2.status = 400; // Bad Request
            return cb(err2);
        }
        return cb(null, decodedToken);
    });
}
exports.extractJwt = extractJwt;


// -------------------------------------------
// Password
// -------------------------------------------
/**
 * Hashes a provided password
 * @param password
 * @param cb func(err, hash)
 */
function hashPassword(password, cb) {
    bcrypt.hash(password, SALTING_ROUNDS, (err, hash) =&gt; {
        if (err) {
            const err = new Error(&apos;password invalid type, password is required&apos;);
            err.status = 400; // Bad Request
            return cb(err);
        }
        return cb(null, hash);
    });
}
exports.hashPassword = hashPassword;


/**
 * Compares a provided password with a hash
 * @param password
 * @param hash
 * @param cb func(err, passwordsMatch)
 */
function comparePassword(password, hash, cb) {
    if (typeof password !== &apos;string&apos;) {
        const err = new Error(&apos;password invalid type, password is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof hash !== &apos;string&apos;) {
        const err = new Error(&apos;hash invalid type, hash is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }

    bcrypt.compare(password, hash, (err, passwordsMatch) =&gt; {
        if (err) {
            console.error(err);
            const err2 = new Error(&apos;password or hash invalid type/data-format&apos;);
            err2.status = 400; // Bad Request
            return cb(err2);
        }
        return cb(null, passwordsMatch);
    });
}
exports.comparePassword = comparePassword;


/**
 * Checks if password is between 8 and 100 characters, if not returns Error
 * @param password password string to check
 * @returns Error object
 */
function validatePasswordLength(password) {
    if (password.length &lt; 8 || password.length &gt; 100) {
        const err = new Error(&apos;password must be between 8 and 100 characters&apos;);
        err.status = 400; // Bad Request
        return err;
    }
    return null;
}


// -------------------------------------------
// User actions
// -------------------------------------------
/**
 * Changes password for userId to newPassword and deletes/revokes all user sessions
 * @param userId
 * @param newPassword
 * @param cb func(err)
 */
function changePassword(userId, newPassword, cb) {
    if (typeof userId !== &apos;string&apos;) {
        const err = new Error(&apos;userId invalid type, userId is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof newPassword !== &apos;string&apos;) {
        const err = new Error(&apos;newPassword invalid type, newPassword is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    // 1. checking pw length
    const err = validatePasswordLength(newPassword);
    if (err)
        return cb(err);

    hashPassword(newPassword, (err, hash) =&gt; {
        if (err)
            return cb(err); // err.status is already set to 400 Bad Request

        User.update({_id: userId}, {$set: {password: hash}}, (err, rawResponse) =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }
            if (rawResponse.n === 0) {
                const err2 = new Error(&apos;user not found&apos;);
                err2.status = 404; // Not Found
                return cb(err2);
            }

            // revoke all user sessions
            revokeAllSessions(userId, err =&gt; {
                if (err)
                    return cb(err);
                return cb(null);
            });
        });
    });
}


/**
 * Changes a users password by providing email + current password to a new password.
 * @param email
 * @param currentPassword
 * @param newPassword
 * @param cb func(err)
 */
function changePasswordViaCurrentPassword(email, currentPassword, newPassword, cb) {
    if (typeof currentPassword !== &apos;string&apos;) {
        const err = new Error(&apos;currentPassword invalid type, currentPassword is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof newPassword !== &apos;string&apos;) {
        const err = new Error(&apos;newPassword invalid type, newPassword is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof email !== &apos;string&apos;) {
        const err = new Error(&apos;email invalid type, email is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    // important: fix email format
    email = email.trim().toLowerCase();

    User.findOne({ email: email }, { _id: 1, password: 1 }, (err, userEntry) =&gt; {
        if (err)
            return cb(new Error(&apos;unknown mongo error&apos;));
        if (userEntry === null) {
            const err2 = new Error(&apos;user not found&apos;);
            err2.status = 404; // Not Found
            return cb(err2);
        }

        comparePassword(currentPassword, userEntry.password, (err, passwordsMatch) =&gt; {
            if (err)
                return cb(err); // err.status is already set
            if (!passwordsMatch) {
                const err2 = new Error(&apos;invalid currentPassword&apos;);
                err2.authHeader = &apos;login realm=&quot;login&quot;&apos;;
                err2.status = 401; // Unauthorized
                return cb(err2);
            }

            changePassword(userEntry._id.toString(), newPassword, err =&gt; {
                if (err)
                    return cb(err); // err.status is already set
                return cb(null);
            });
        });
    });
}
exports.changePasswordViaCurrentPassword = changePasswordViaCurrentPassword;


/**
 * Changes a users password by providing password rest token to a new password.
 * @param token passwortResetToken
 * @param newPassword
 * @param cb func(err)
 */
function changePasswordViaResetToken(token, newPassword, cb) {
    if (typeof newPassword !== &apos;string&apos;) {
        const err = new Error(&apos;newPassword invalid type, newPassword is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }

    extractJwt(token, (err, decoded) =&gt; {
        if (err)
            return cb(err); // err.status is already set to 400 Bad Request

        changePassword(decoded[&apos;userId&apos;], newPassword, err =&gt; {
            if (err)
                return cb(err); // err.status is already set
            return cb(null);
        });
    });
}
exports.changePasswordViaResetToken = changePasswordViaResetToken;


/**
 * Creates email validation token for user with provided email and sends it to users email
 * @param email
 * @param cb func(err)
 */
function createAndSendEmailValidationToken(email, cb) {
    if (typeof email !== &apos;string&apos;) {
        const err = new Error(&apos;email invalid type, email is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    // important: fix email format
    email = email.trim().toLowerCase();

    User.findOne({ email: email }, { _id: 1, emailValidated: 1 }, (err, userEntry) =&gt; {
        if (err)
            return cb(new Error(&apos;unknown mongo error&apos;));
        if (userEntry === null) {
            const err2 = new Error(&apos;user not found&apos;);
            err2.status = 404; // Not Found
            return cb(err2);
        }
        if (userEntry.emailValidated === true) {
            const err2 = new Error(&apos;user already validated&apos;);
            err2.status = 409; // Conflict
            return cb(err2);
        }
        createEmailValidationToken(userEntry._id.toString(), (err, token) =&gt; {
            if (err)
                return cb(new Error(&apos;could not create email validation token&apos;));

            // call callback for success (before sending mail)
            cb(null);

            // send mail in background
            const validateLink = REQUEST_URL_VALIDATE_EMAIL.replace(/:token/g, token);
            const body = MAIL_ACTIVATE_USER_BODY.join(&apos;&apos;).replace(/:validate-link/g, validateLink);
            const mailOptions = {
                from: mailer.FROM,
                to: email,
                subject: MAIL_ACTIVATE_USER_SUBJECT,
                html: body
            };

            mailer.sendMail(mailOptions, (error, info) =&gt; {
                if (error)
                    return console.error(error);
                console.log(&apos;Validation email sent to: &apos; + email + &apos;, id: &apos; + info.messageId);
            });
        });
    });
}
exports.createAndSendEmailValidationToken = createAndSendEmailValidationToken;


/**
 * Creates password reset token for user with provided email and sends it to users email
 * @param email
 * @param cb func(err)
 */
function createAndSendPasswordResetToken(email, cb) {
    if (typeof email !== &apos;string&apos;) {
        const err = new Error(&apos;email invalid type, email is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    // important: fix email format
    email = email.trim().toLowerCase();

    User.findOne({ email: email }, { _id: 1 }, (err, userEntry) =&gt; {
        if (err)
            return cb(new Error(&apos;unknown mongo error&apos;));
        if (userEntry === null) {
            const err2 = new Error(&apos;user not found&apos;);
            err2.status = 404; // Not Found
            return cb(err2);
        }
        createPasswordResetToken(userEntry._id, (err, token) =&gt; {
            if (err)
                return cb(new Error(&apos;could not create password reset token&apos;));

            // call callback for success (before sending mail)
            cb(null);

            // send mail in background
            const passwordResetLink = REQUEST_URL_RESET_PASSWORD.replace(/:token/g, token);
            const body = MAIL_RESET_PASSWORD_BODY.join(&apos;&apos;).replace(/:password-reset-link/g, passwordResetLink);
            const mailOptions = {
                from: mailer.FROM,
                to: email,
                subject: MAIL_RESET_PASSWORD_SUBJECT,
                html: body
            };

            mailer.sendMail(mailOptions, (error, info) =&gt; {
                if (error)
                    return console.error(error);
                console.log(&apos;Password reset email sent to: &apos; + email + &apos;, id: &apos; + info.messageId);
            });
        });
    });
}
exports.createAndSendPasswordResetToken = createAndSendPasswordResetToken;


/**
 * Creates new user by
 * 1. checking password length (8 &lt;= pw.len &lt;= 100),
 * 2. hashing pw via bcrypt,
 * 3. creating root folder,
 * 4. creating user instance,
 * 5. saving user instance to db
 * and returning user
 * @param name
 * @param email
 * @param password
 * @param cb func(err, user)
 */
function createUser(name, email, password, cb) {
    if (typeof email !== &apos;string&apos;) {
        const err = new Error(&apos;email invalid type, email is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof password !== &apos;string&apos;) {
        const err = new Error(&apos;password invalid type, password is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    // 1. checking pw length
    const err = validatePasswordLength(password);
    if (err)
        return cb(err);

    // important: fix email format
    email = email.trim().toLowerCase();

    // 2. hashing pw
    hashPassword(password, (err, hash) =&gt; {
        if (err)
            return cb(err); // err.status is already set to 400 Bad Request

        // userId
        const userId = mongoose.Types.ObjectId();

        // 3. create root folder
        let rootFolder = new Folder({
            &apos;title&apos;: &apos;/&apos;,
            &apos;parentId&apos;: null,
            &apos;ownerId&apos;: userId
        });

        rootFolder.save((err, folderEntry) =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }

            // 4. creating user instance
            const user = new User({
                &apos;_id&apos;: userId,
                &apos;name&apos;: name,
                &apos;email&apos;: email,
                &apos;password&apos;: hash,
                &apos;folderId&apos;: folderEntry._id
            });

            // 5. saving user instance
            user.save((err, userEntry) =&gt; {
                if (err) {
                    // remove previously created folder
                    folderEntry.remove(err =&gt; {
                        if (err)
                            console.error(err);
                    });

                    if (err.message.startsWith(&apos;User validation failed&apos;)) {
                        err.status = 400; // Bad Request
                        return cb(err);
                    }
                    // 11000: duplicate key (for email)
                    if (err.name === &apos;MongoError&apos; &amp;&amp; err.code === 11000  &amp;&amp; err.message.indexOf(user.email) !== -1) {
                        const err = new Error(&apos;email already exists&apos;);
                        err.status = 409; // Conflict
                        return cb(err);
                    }
                    console.error(err);
                    return cb(new Error(&apos;unknown mongo error&apos;));
                }
                return cb(null, userEntry);
            });
        });
    });
}
exports.createUser = createUser;


/**
 * Authenticates user and creates session by
 * 1. finding user by email,
 * 2. comparing password and hash,
 * 3. creating session,
 * 4. creating session token
 * and returning session token
 * @param email
 * @param password
 * @param cb func(err, sessionToken, name, folderId, userId) name corresponds the users name e.g. &quot;Max Mustermann&quot;, folderId is the users root folder
 */
function login(email, password, cb) {
    if (typeof email !== &apos;string&apos;) {
        const err = new Error(&apos;email invalid type, email is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }
    if (typeof password !== &apos;string&apos;) {
        const err = new Error(&apos;password invalid type, password is required&apos;);
        err.status = 400; // Bad Request
        return cb(err);
    }

    // important: fix email format
    email = email.trim().toLowerCase();

    // 1. find user by email
    User.findOne({ email: email }, { _id: 1, name:1, emailValidated: 1, password: 1, sessions: 1, folderId: 1 }, (err, userEntry) =&gt; {
        if (err) {
            console.error(err);
            return cb(new Error(&apos;unknown mongo error&apos;));
        }
        if (userEntry === null) {
            const err2 = new Error(&apos;user not found&apos;);
            err2.authHeader = &apos;login realm=&quot;login&quot;&apos;;
            err2.status = 401; // Unauthorized
            return cb(err2);
        }
        if (userEntry.emailValidated === false) {
            const err2 = new Error(&apos;user account not validated&apos;);
            err2.authHeader = &apos;emailValidation realm=&quot;emailValidation&quot;&apos;;
            err2.status = 401; // Unauthorized
            return cb(err2);
        }

        // 2. compare passwords
        comparePassword(password, userEntry.password, (err, passwordsMatch) =&gt; {
            if (err)
                return cb(err); // err.status is already set
            if (!passwordsMatch) {
                const err2 = new Error(&apos;invalid password&apos;);
                err2.authHeader = &apos;login realm=&quot;login&quot;&apos;;
                err2.status = 401; // Unauthorized
                return cb(err2);
            }

            // 3. create session
            // TODO add expires and description fields
            const newSession = userEntry.sessions.create({});
            userEntry.sessions.push(newSession);
            userEntry.save(err =&gt; {
                if (err) {
                    console.error(err);
                    return cb(new Error(&apos;unknown mongo error&apos;));
                }

                // 4. create session token
                createSessionToken(userEntry._id.toString(), newSession._id.toString(), (err, sessionToken) =&gt; {
                    if (err)
                        return cb(new Error(&apos;could not create session token&apos;));
                    return cb(null, sessionToken, userEntry.name, userEntry.folderId.toString(), userEntry._id.toString());
                });
            });
        });
    });
}
exports.login = login;


/**
 * Logout a provided session (via session token)
 * @param token sessionToken
 * @param cb func(err)
 */
function logout(token, cb) {
    extractJwt(token, (err, decoded) =&gt; {
        if (err)
            return cb(err); // err.status already set

        User.findById(decoded[&apos;userId&apos;], { sessions: 1 }, (err, userEntry) =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }
            if (userEntry === null) {
                const err2 = new Error(&apos;user not found&apos;);
                err2.status = 404; // Not Found
                return cb(err2);
            }
            // find &amp; remove session
            const session = userEntry.sessions.find((elem) =&gt; {
                return elem._id.toString() === decoded.sessionId;
            });
            if (session === undefined) {
                const err2 = new Error(&apos;invalid session&apos;);
                err2.authHeader = &apos;login realm=&quot;login&quot;&apos;;
                err2.status = 401; // Unauthorized
                return cb(err2);
            }
            session.remove();

            userEntry.save(err =&gt; {
                if (err) {
                    console.error(err);
                    return cb(new Error(&apos;unknown mongo error&apos;));
                }
                return cb(null);
            })
        });
    });
}
exports.logout = logout;


/**
 * Iterates over sessions in userEntry and removes expired ones
 * @param userEntry user-db object
 */
function removeExpiredSessionsFromUserEntry(userEntry) {
    for (let i = userEntry.sessions.length - 1; i &gt;= 0; i--) {
        if (userEntry.sessions[i].get(&apos;expires&apos;)) {
            if (userEntry.sessions[i].expires.getTime() &lt; Date.now())
                userEntry.sessions[i].remove();
        }
    }
}


/**
 * Removes/revokes all sessions from a userEntry
 * @param userId
 * @param cb func(err)
 */
function revokeAllSessions(userId, cb) {
    User.findById(userId, { sessions: 1 }, (err, userEntry) =&gt; {
        if (err) {
            console.error(err);
            return cb(new Error(&apos;unknown mongo error&apos;));
        }
        if (userEntry === null) {
            const err2 = new Error(&apos;user not found&apos;);
            err2.status = 404; // Not Found
            return cb(err2);
        }
        userEntry.sessions.splice(0, userEntry.sessions.length);
        userEntry.save(err =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }
            return cb(null);
        });
    });
}
exports.revokeAllSessions = revokeAllSessions;


// TODO proper refactor instead of this BS
function validateSessionAsyncWrapper(sessionToken) {
    return new Promise((resolve, reject) =&gt; {
        validateSession(sessionToken, (err, userId) =&gt; {
            if (err)
                reject(err);
            else
                resolve(userId);
        });
    });
}
exports.validateSessionAsyncWrapper = validateSessionAsyncWrapper;
/**
 * Validates a provided session (as sessionToken) by
 * 1. extracting jwt
 * 2. querying user
 * 3. check sessions
 * 4. saving user entry
 * and returning userId
 * @param token sessionToken
 * @param cb func(err, userId)
 */
function validateSession(token, cb) {
    // 1. extract jwt
    extractJwt(token, (err, decoded) =&gt; {
        if (err) {
            if (err.message.startsWith(&apos;invalid token&apos;)) {
                err.authHeader = &apos;login realm=&quot;login&quot;&apos;;
                err.status = 401; // Unauthorized
            }
            return cb(err);
            /*
            There is no need to check whether jwt is expired,
            because sessionTokens cannot expire atm.
            Expiry is set server-side (in db)
             */
        }

        // 2. querying user
        User.findById(decoded.userId, { sessions: 1 }, (err, userEntry) =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }
            if (userEntry === null) {
                const err2 = new Error(&apos;user not found&apos;);
                err2.status = 404; // Not Found
                return cb(err2);
            }

            // 3. check sessions
            removeExpiredSessionsFromUserEntry(userEntry);

            // 4. saving user entry
            userEntry.save((err, userEntry) =&gt; {
                if (err) {
                    console.error(err);
                    return cb(new Error(&apos;unknown mongo error&apos;));
                }
                // no session found =&gt; expired
                const session = userEntry.sessions.find((elem) =&gt; {
                    return elem._id.toString() === decoded.sessionId;
                });
                if (session === undefined) {
                    const err2 = new Error(&apos;session expired&apos;);
                    err2.authHeader = &apos;login realm=&quot;login&quot;&apos;;
                    err2.status = 401; // Unauthorized
                    return cb(err2);
                }
                return cb(null, decoded.userId);
            });
        });
    });
}
exports.validateSession = validateSession;


/**
 * Marks user email as validated if given token is valid
 * @param token valid EmailValidationToken
 * @param cb func(err)
 */
function validateUserEmail(token, cb) {
    extractJwt(token, (err, decoded) =&gt; {
        if (err)
            return cb(err); // err.status is already set to 400 Bad Request

        User.update({ _id: decoded[&apos;userId&apos;] }, { $set: { emailValidated: true } }, (err, rawResponse) =&gt; {
            if (err) {
                console.error(err);
                return cb(new Error(&apos;unknown mongo error&apos;));
            }
            if (rawResponse.n === 0) {
                const err2 = new Error(&apos;user not found&apos;);
                err2.status = 404; // Not Found
                return cb(err2);
            }
            if (rawResponse.nModified === 0) {
                const err2 = new Error(&apos;user already validated&apos;);
                err2.status = 409; // Conflict
                return cb(err2);
            }
            return cb(null);
        });
    });
}
exports.validateUserEmail = validateUserEmail;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
